-props: props are Properties, Passing a prop to a component is same as passing a argument to a function.

1. When we have to dynamically pass in some data to a component we pass in as a prop.

// swiggy restaurant image
https://media-assets.swiggy.com/swiggy/image/upload/fl_lossy,f_auto,q_auto,w_660/RX_THUMBNAIL/IMAGES/VENDOR/2024/9/18/2fb56c16-5ba2-4f29-a978-e059399f8c37_30237.jpg

// Swiggy API
https://www.swiggy.com/dapi/restaurants/list/v5/?lat=12.9351929&lng=77.62448069999999&page_type=DESKTOP_WEB_LISTING

// bhayandar API

https://www.swiggy.com/mapi/homepage/getCards?lat=19.306523036370468&lng=72.86280434578657&page_type=DESKTOP_WEB_LISTING

setListOfRestaurants(json?.data?.success?.cards[4]?.gridWidget?.gridElements?.infoWithStyle?.restaurants)

- config driven UI: All the UI is driven by the config (data) the data can be different for any circumstances, we can control the UI from the Backend.(specially used for different locations different data)

<!-- key while looping -->
- why key is important when using map: when components have childrens they have same level components they should be uniquely represented, because when we do not use key property react does not get to know which new set of data is added in the array and it will re-render all the data which is not a good practice for performance and optimization, that is why key is important so that react should know which data is newly added and only render that set of data.

- why using index as a key is a bad practice: It works fine as soon as we add a new child component, react gets confused about which properties belonged to which map component. so key={index} is not recommended itself by react official.

- not using keys (not acceptable) <<<<<< index as key <<<<< unique id (best practice)

<!-- two types of export -->

<!-- default -->

1. export default Header;

<!-- named export -->

2. when you have to export multiple things in a components file than we use named export. It is basically writing export in front of const or variable, because there cannot be two default in a file.

if we use named export then while importing it should be like this,
import {CDN_URL} from "../utils/constants"

And also we can use name export and default export in the same file.

<!-- React Hooks -->

(Normal Js utility functions)

- useState() - Superpowerful State variables in react
- useEffect()


<!-- import useState -->

import {useState} from "react";

<!-- Local State Variable - Superpowerful variable  -->

const [listItems] = useState([]);

<!-- Array destructuring -->

// OR
const arr = useState(resList);
const [listItems, setListItems] = arr;

// OR
const arr = useState(resList);
const listItems = arr[0]
const setListItems = arr[1]

<!-- Normal Js Variable -->

let listOfRestaurants = []

<!-- whenever a state variable updates, react rerenders the components  -->

<!-- React keeps our UI sync with data layer in data layer when you have a local state variable as soon as your data layer updates, your UI layer will update by re-rendering the components in a very less code and optimized way, also with super fast DOM operations and efficiency -->

<!-- React is very good at DOM operations -->

<!-- Reconciliation Algorithm -->

When something changes in the UI is known as reconciliation,The algorithm React uses to diff one tree with another to determine which parts need to be changed.A change in the data used to render a React app. Usually the result of `setState`. Eventually results in a re-render.

<!-- Virtual DOM -->

Virtual DOM: Virtal DOM is a representation of actual DOM. It is kind of nothing but a JS object. React is doing Efficient Dom manipulation. 
 
<!-- Diffing Algorithm -->

Diffing Algorithm finds out the difference between updated virtual dom and previous virtual dom, and then actually updates the dom on every render cycle.

<!-- React Fiber -->

Incremental Rendering: The ability to split rendering work into chunks and spread out over multiple frames.

<-- useEffect() -->

It takes two arguments first is a callback function and second is a dependency array.

If no dependency array => useEffect is called on every render.
If dependency array is empty = [] => useEffect is called on initial render(just once)
If dependency array is [btnNameReact] => called everytime btnNameReact is updated.

// Optional Chaining
setListOfRestaurants(json?.data?.cards[4]?.card?.card?.gridElements?.infoWithStyle?.restaurants)
   
The optional chaining (?.) operator accesses an object's property or calls a function. If the object accessed or function called using this operator is undefined or null, the expression short circuits and evaluates to undefined instead of throwing an error.

// Conditional Rendering
if (ListOfRestaurants.length === 0) {
return <Shimmer /> 
}  

In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.

Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like if or the conditional operator to create elements representing the current state, and let React update the UI to match them.

<!-- Shimmer UI -->

A better way to show loading states is to use a shimmer UI. A shimmer UI is a version of the UI that doesn't contain actual content, but instead mimics the layout and shapes of the content that will eventually appear. It uses a gradient animation that creates a shimmering effect over the placeholders, giving the user a sense of motion and progress.

<!-- why local state variable is advanced over normal variable   -->

when you try to update the normal variable in onclick function you will end up getting no changes bcoz it won't let us so in here useState help with const variable and two arguments it re-renders the whole component so const has a principle of not letting the data change but here the whole reconciliation cycle gets updates so no problem in const

whenever state variables update, react triggers a reconciliation cycle(re-renders the component)

<!-- cors plugin -->

CORS: Cross Origin Resources Sharing
It bypasses the cors issue.

.Use Another Public CORS Proxy
There are other public CORS proxies that you can try, such as:
https://cors-anywhere.herokuapp.com/
https://api.allorigins.win/get?url=
https://thingproxy.freeboard.io/fetch/

<!-- Hooks -->

// A hook should be created inside a component always, bcoz the purpose is to create local state variable inside functional component and use the hooks at the top also good for synchronours single threaded language.

// Never use hooks inside if else statements, functions and for loops, it can create inconsistency, bcoz the state variable are meant to be created inside function component and on the higher level.

<!-- Routes -->

import { createBrowserRouter, RouterProvider, Outlet } from "react-router-dom";

root.render(<RouterProvider router={AppRouter} />)

<!-- Error page -->

import Error from "./components/Error";

errorElement: <Error />

<!-- children routes -->

Outlet replace itself with the route page

children: [
{
path: "/",
element: <Body />,
}, {
path: "/about",
element: <About />,
}, {
path: "/contact",
element: <Contact />,
}
],

// Our applications are known as single page applications. New Pages are just components interchanging themselves. Everything is component in react.

<!-- Two types of routing -->

// Client side Routing
In traditional websites, the browser requests a document from a web server, downloads and evaluates CSS and JavaScript assets, and renders the HTML sent from the server. When the user clicks a link, it starts the process all over again for a new page.

Client side routing allows your app to update the URL from a link click without making another request for another document from the server. Instead, your app can immediately render some new UI and make data requests with fetch to update the page with new information.

Client side routing is enabled by creating a Router and linking/submitting to pages with <Link> and <Form>

// Server side Routing

Server-side routing is a traditional approach to handling routes in web applications. It involves the server sending a response based on the URL path that the user is visiting

<!-- Dynamic Routing -->

<!-- Install react-router-dom -->

// npm i react-router-dom

<!-- https://swiggy.com/dapi/menu/pl?page-type-REGULAR_MENU&complete-menu=true&lat=12.9351929&lng=77.62448069999999&restaurantId-425&submitAction=ENTER -->

<!-- Link  -->

// Link is a wrapper over anchor tag

<!-- class components -->

// never directly update state variables.

// when you update one element of state variable in setState the other element will remain still.

<!-- React.component / Component -->

//if used React.Component then the import should be import react from "react";

// if used Component then the import will be import {Component} from "react";

<!-- Super -->

// Accessing this in the Constructor: In JavaScript, you can't use this in a constructor until you've called the parent's constructor with super(). React components extend from React.Component, so you must call super() first if you want to access this in your componentâ€™s constructor. Without calling super(), you would not be able to use this to refer to the component instance in the constructor.

<!-- Parent and child in class component -->

//  The sequence goes like this, First the Parent constructor is called then the Parent render is called as soon the parent render is called it will call child constructor and child render after that now the component is mounted so the ComponentDidMount is called of the Child and afterwards Parent's  ComponentDidMount will be called.


<!-- LifeCycle -->

// Render phase: First the Parent constructor is called then parent render is called after that first child constructor and render is called same for the another and many more children.

// Commit Phase: Once the commit phase starts react tries to update the dom and dom manipulation is the most expensive thing when we are updating a component.

// Render phase is just virtual dom it finds the diff and when it tries to update the dom it batches all the children's and later on commit phase happens which means first child Component did mount then second child and so on and afterwards parent Component did mount. 